

let Ajv: typeof import("ajv");
try {
  Ajv = require("ajv");
} catch (e) {
  throw new Error("Module 'ajv' not found. Please install it with 'npm install ajv'.");
}
import addFormats from "ajv-formats";
import schema from "../schema/holiday.schema.json" assert { type: "json" };
import { Holiday } from "./types";

const ajv = new Ajv({ allErrors: true, strict: false });
addFormats(ajv);
const validateFn = ajv.compile(schema);

export function validateHoliday(h: unknown): Holiday {
  if (!validateFn(h)) {
    const msg = ajv.errorsText(validateFn.errors, { separator: "\n" });
    throw new Error(`Invalid holiday:\n${msg}`);
  }
  return h as Holiday;
}


Normalize (src/core/normalize.ts)

import { Holiday } from "./types";

export function normalize(h: Holiday): Holiday {
  const out: Holiday = { ...h };
  // Ensure lowercase id slugs and stable timestamps
  out.id = h.id.trim().toLowerCase().replace(/[^a-z0-9-]/g, "-");
  out.updatedAt = new Date().toISOString();

  // Default timezone
  if (!out.date.timezone) out.date.timezone = "UTC";

  // If range missing end, assume same-day
  if (out.date.type === "range" && !out.date.end && out.date.start) {
    out.date.end = out.date.start;
  }

  // Deduplicate aliases
  if (out.aliases) {
    out.aliases = Array.from(new Set(out.aliases.map(a => a.trim()))).filter(Boolean);
  }
  return out;
}


Merge with conflict safety (src/core/merge.ts)

import { Holiday } from "./types";

export function mergeHolidays(sources: Holiday[][]): Holiday[] {
  const map = new Map<string, Holiday>();
  for (const src of sources) {
    for (const h of src) {
      const key = h.id;
      const existing = map.get(key);
      if (!existing) {
        map.set(key, h);
      } else {
        // Prefer newest updatedAt; merge arrays/fields
        const newer = (h.updatedAt ?? "") > (existing.updatedAt ?? "") ? h : existing;
        const merged: Holiday = {
          ...existing,
          ...h,
          aliases: Array.from(new Set([...(existing.aliases ?? []), ...(h.aliases ?? [])])),
          links: Array.from(new Set([...(existing.links ?? []), ...(h.links ?? [])]))
        };
        // Preserve the newer date block whole (date rules must be atomic)
        merged.date = newer.date;
        merged.updatedAt = newer.updatedAt;
        map.set(key, merged);
      }
    }
  }
  // Sort deterministic: tradition, name, then id
  return Array.from(map.values()).sort((a, b) =>
    (a.tradition.localeCompare(b.tradition) ||
     a.name.localeCompare(b.name) ||
     a.id.localeCompare(b.id))
  );
}


Exports (JSON, CSV, ICS) (src/core/exports.ts)

import { Holiday } from "./types";
import { writeFileSync } from "fs";

export function exportJSON(holidays: Holiday[], path = "data/holidays.json") {
  writeFileSync(path, JSON.stringify(holidays, null, 2), "utf-8");
}

export function exportCSV(holidays: Holiday[], path = "data/holidays.csv") {
  const headers = ["id","name","tradition","type","value","start","end","timezone","scope","regions","beginsAtSunset","workRestrictions","fasting","year","updatedAt"];
  const rows = holidays.map(h => [
    h.id, h.name, h.tradition,
    h.date.type, h.date.value ?? "", h.date.start ?? "", h.date.end ?? "", h.date.timezone ?? "",
    h.scope, (h.regions ?? []).join(";"),
    h.observance?.beginsAtSunset ?? false,
    h.observance?.workRestrictions ?? "",
    h.observance?.fasting ?? false,
    h.year ?? "",
    h.updatedAt ?? ""
  ]);
  const csv = [headers.join(","), ...rows.map(r => r.map(v => String(v).replace(/"/g, '""')).map(v => `"${v}"`).join(","))].join("\n");
  writeFileSync(path, csv, "utf-8");
}

export function exportICS(holidays: Holiday[], path = "data/holidays.ics") {
  const lines = ["BEGIN:VCALENDAR","VERSION:2.0","PRODID:-//GlobalHolidayCalendar//EN"];
  for (const h of holidays) {
    const dtStart = (h.date.type === "fixed" ? h.date.value : h.date.start) ?? "";
    const dtEnd = (h.date.type === "range" ? h.date.end : dtStart) ?? dtStart;
    if (!dtStart) continue;
    const start = dtStart.replace(/-/g, "") + "T000000Z";
    const end = dtEnd.replace(/-/g, "") + "T235959Z";
    lines.push(
      "BEGIN:VEVENT",
      `UID:${h.id}@globalholiday.calendar`,
      `DTSTAMP:${(h.updatedAt ?? new Date().toISOString()).replace(/[-:]/g, "").split(".")[0]}Z`,
      `DTSTART:${start}`,
      `DTEND:${end}`,
      `SUMMARY:${escapeICS(h.name)} (${h.tradition})`,
      `DESCRIPTION:${escapeICS(h.description ?? "")}`,
      "END:VEVENT"
    );
  }
  lines.push("END:VCALENDAR");
  require("fs").writeFileSync(path, lines.join("\r\n"), "utf-8");

  function escapeICS(s: string) {
    return s.replace(/\\/g, "\\\\").replace(/;/g, "\\;").replace(/,/g, "\\,").replace(/\n/g, "\\n");
  }
}


Build orchestrator (src/index.ts)

import { validateHoliday } from "./core/validate";
import { normalize } from "./core/normalize";
import { mergeHolidays } from "./core/merge";
import { exportJSON, exportCSV, exportICS } from "./core/exports";
import { adapters } from "./adapters/user-contrib"; // plus static adapters
import { staticJewish } from "./adapters/static-jewish";
import { staticIslamic } from "./adapters/static-islamic";
import { staticChristian } from "./adapters/static-christian";
import { staticBahai } from "./adapters/static-bahai";
import { staticHindu } from "./adapters/static-hindu";
import { staticBuddhist } from "./adapters/static-buddhist";

async function build() {
  const allSources = [];
  // Run adapters concurrently
  const results = await Promise.all([
    staticJewish(), staticIslamic(), staticChristian(),
    staticBahai(), staticHindu(), staticBuddhist(),
    ...adapters.map(a => a.run())
  ]);

  for (const res of results) {
    const cleaned = res.map(h => normalize(validateHoliday(h)));
    allSources.push(cleaned);
  }

  const merged = mergeHolidays(allSources);
  exportJSON(merged);
  exportCSV(merged);
  exportICS(merged);
  console.log(`Built ${merged.length} holidays -> data/holidays.*`);
}

build().catch(err => {
  console.error(err);
  process.exit(1);
});


---
