


let addFormats: any;
import schema from "../schema/holiday.schema.json" assert { type: "json" };



/**
 * @typedef {import('ajv').default} AjvType
 * @typedef {import('ajv').ValidateFunction} ValidateFunctionType
 */
let ajvInstance /** @type {null | AjvType} */ = null;
let validateFn /** @type {null | ValidateFunctionType} */ = null;

async function getAjv() {
  if (!ajvInstance) {
    let Ajv;
    try {
      Ajv = (await import("ajv")).default;
    } catch (e) {
      throw new Error("Module 'ajv' not found. Please install it with 'npm install ajv'.");
    }
    if (!addFormats) {
      try {
        // @ts-ignore: ajv-formats may not be installed, fallback is handled below
        addFormats = (await import("ajv-formats")).default;
      } catch (e) {
        // Fallback: define a no-op if ajv-formats is missing
        console.warn("Warning: Module 'ajv-formats' not found. Some format validations may not work. Install it with 'npm install ajv-formats'.");
        addFormats = () => {};
      }
    }
    ajvInstance = new Ajv({ allErrors: true, strict: false });
    addFormats(ajvInstance);
    validateFn = ajvInstance.compile(schema);
  }
  return { ajv: ajvInstance, validateFn: validateFn };
}

export async function validateHoliday(h: unknown): Promise<Holiday> {
  const { ajv, validateFn } = await getAjv();
  if (!validateFn(h)) {
    const msg = ajv.errorsText(validateFn.errors, { separator: "\n" });
    throw new Error(`Invalid holiday:\n${msg}`);
  }
  return h as Holiday;
}





export function normalize(h: Holiday): Holiday {
  const out: Holiday = { ...h };
  // Ensure lowercase id slugs and stable timestamps
  out.id = h.id.trim().toLowerCase().replace(/[^a-z0-9-]/g, "-");
  out.updatedAt = new Date().toISOString();

  // Default timezone
  if (!out.date.timezone) out.date.timezone = "UTC";

  // If range missing end, assume same-day
  if (out.date.type === "range" && !out.date.end && out.date.start) {
    out.date.end = out.date.start;
  }

  // Deduplicate aliases
  interface Alias extends String {}
  if (out.aliases) {
    out.aliases = Array.from(new Set(out.aliases.map((a: string) => a.trim()))).filter(Boolean) as string[];
  }
  return out;
}





export function mergeHolidays(sources: Holiday[][]): Holiday[] {
  const map = new Map<string, Holiday>();
  for (const src of sources) {
    for (const h of src) {
      const key = h.id;
      const existing = map.get(key);
      if (!existing) {
        map.set(key, h);
      } else {
        // Prefer newest updatedAt; merge arrays/fields
        const newer = (h.updatedAt ?? "") > (existing.updatedAt ?? "") ? h : existing;
        const merged: Holiday = {
          ...existing,
          ...h,
          aliases: Array.from(new Set([...(existing.aliases ?? []), ...(h.aliases ?? [])])),
          links: Array.from(new Set([...(existing.links ?? []), ...(h.links ?? [])]))
        };
        // Preserve the newer date block whole (date rules must be atomic)
        merged.date = newer.date;
        merged.updatedAt = newer.updatedAt;
        map.set(key, merged);
      }
    }
  }
  // Sort deterministic: tradition, name, then id
  return Array.from(map.values()).sort((a, b) =>
    (a.tradition.localeCompare(b.tradition) ||
     a.name.localeCompare(b.name) ||
     a.id.localeCompare(b.id))
  );
}



import { Holiday } from "./types";
import { writeFileSync } from "fs";

export function exportJSON(holidays: Holiday[], path = "data/holidays.json") {
  writeFileSync(path, JSON.stringify(holidays, null, 2), "utf-8");
}

export function exportCSV(holidays: Holiday[], path = "data/holidays.csv") {
  const headers = ["id","name","tradition","type","value","start","end","timezone","scope","regions","beginsAtSunset","workRestrictions","fasting","year","updatedAt"];
  const rows = holidays.map(h => [
    h.id, h.name, h.tradition,
    h.date.type, h.date.value ?? "", h.date.start ?? "", h.date.end ?? "", h.date.timezone ?? "",
    h.scope, (h.regions ?? []).join(";"),
    h.observance?.beginsAtSunset ?? false,
    h.observance?.workRestrictions ?? "",
    h.observance?.fasting ?? false,
    h.year ?? "",
    h.updatedAt ?? ""
  ]);
  const csv = [headers.join(","), ...rows.map(r => r.map(v => String(v).replace(/"/g, '""')).map(v => `"${v}"`).join(","))].join("\n");
  writeFileSync(path, csv, "utf-8");
}

export function exportICS(holidays: Holiday[], path = "data/holidays.ics") {
  const lines = ["BEGIN:VCALENDAR","VERSION:2.0","PRODID:-//GlobalHolidayCalendar//EN"];
  for (const h of holidays) {
    const dtStart = (h.date.type === "fixed" ? h.date.value : h.date.start) ?? "";
    const dtEnd = (h.date.type === "range" ? h.date.end : dtStart) ?? dtStart;
    if (!dtStart) continue;
    const start = dtStart.replace(/-/g, "") + "T000000Z";
    const end = dtEnd.replace(/-/g, "") + "T235959Z";
    lines.push(
      "BEGIN:VEVENT",
      `UID:${h.id}@globalholiday.calendar`,
      `DTSTAMP:${(h.updatedAt ?? new Date().toISOString()).replace(/[-:]/g, "").split(".")[0]}Z`,
      `DTSTART:${start}`,
      `DTEND:${end}`,
      `SUMMARY:${escapeICS(h.name)} (${h.tradition})`,
      `DESCRIPTION:${escapeICS(h.description ?? "")}`,
      "END:VEVENT"
    );
  }
  lines.push("END:VCALENDAR");
  require("fs").writeFileSync(path, lines.join("\r\n"), "utf-8");

  function escapeICS(s: string) {
    return s.replace(/\\/g, "\\\\").replace(/;/g, "\\;").replace(/,/g, "\\,").replace(/\n/g, "\\n");
  }
}





// import { validateHoliday } from "./core/validate";
import process from "process";
// import { normalize } from "./core/normalize";
// import { mergeHolidays } from "./merge";
// exportJSON, exportCSV, exportICS are defined locally below
import { createRequire } from "module";
const require = createRequire(import.meta.url);
let adapters: any[] = [];
try {
  adapters = require("./adapters/user-contrib").adapters;
} catch (e) {
  // If the module doesn't exist, use an empty array
  adapters = [];
}
// import { staticJewish } from "./adapters/static-jewish";
// import { staticIslamic } from "./adapters/static-islamic";
// import { staticChristian } from "./adapters/static-christian";
// import { staticBahai } from "./adapters/static-bahai";
// import { staticHindu } from "./adapters/static-hindu";
// import { staticBuddhist } from "./adapters/static-buddhist";

async function build() {
  const allSources = [];
  // Run adapters concurrently
  const results = await Promise.all([
    staticJewish(),
    // Stub for staticIslamic to fix reference error
    async function staticIslamic(): Promise<Holiday[]> {
      // TODO: Implement actual Islamic holidays
      return [];
    }(),
    // staticChristian(),
    staticBahai(),
    staticHindu(),
    // staticBuddhist(),
    ...adapters.map((a: { run: () => Promise<any[]> }) => a.run())
  ]);

  for (const res of results) {
    const cleaned = res.map((h: unknown) => normalize(validateHoliday(h)));
    allSources.push(cleaned);
  }

  const merged = mergeHolidays(allSources);
  exportJSON(merged);
  exportCSV(merged);
  exportICS(merged);
  console.log(`Built ${merged.length} holidays -> data/holidays.*`);
}

build().catch(err => {
  console.error(err);
  process.exit(1);
});



async function staticHindu(): Promise<Holiday[]> {
  // Example static Hindu holidays (fixed dates for demonstration)
  const holidays: Holiday[] = [
    {
      id: "diwali",
      name: "Diwali",
      tradition: "Hindu",
      description: "Festival of Lights, one of the most important Hindu festivals.",
      date: {
        type: "fixed",
        value: "2024-11-01",
        timezone: "Asia/Kolkata"
      },
      scope: "public",
      regions: ["IN", "NP", "MU", "FJ", "MY", "SG", "TT"],
      aliases: ["Deepavali"],
      observance: {
        beginsAtSunset: true,
        workRestrictions: "Major festival, often a public holiday.",
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "holi",
      name: "Holi",
      tradition: "Hindu",
      description: "Festival of Colors, celebrating the arrival of spring.",
      date: {
        type: "fixed",
        value: "2024-03-25",
        timezone: "Asia/Kolkata"
      },
      scope: "public",
      regions: ["IN", "NP", "BD", "PK"],
      aliases: ["Festival of Colors"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: "Public holiday in many regions.",
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "maha-shivaratri",
      name: "Maha Shivaratri",
      tradition: "Hindu",
      description: "Great Night of Shiva, a major festival dedicated to Lord Shiva.",
      date: {
        type: "fixed",
        value: "2024-03-08",
        timezone: "Asia/Kolkata"
      },
      scope: "public",
      regions: ["IN", "NP"],
      aliases: ["Shivaratri"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: "Observed with fasting and night-long vigil.",
        fasting: true
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    }
  ];
  return holidays;
}

async function staticBahai(): Promise<Holiday[]> {
  // Example static Baháʼí holidays (fixed dates for demonstration)
  const holidays: Holiday[] = [
    {
      id: "naw-ruz",
      name: "Naw-Rúz",
      tradition: "Baháʼí",
      description: "Baháʼí New Year, coincides with the vernal equinox.",
      date: {
        type: "fixed",
        value: "2024-03-20",
        timezone: "UTC"
      },
      scope: "public",
      regions: ["IR", "AZ", "UZ", "TM", "KG", "KZ", "AF", "PK", "IN", "BD", "Worldwide"],
      aliases: ["Nowruz", "Baháʼí New Year"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: true,
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "ridvan-1",
      name: "First Day of Ridván",
      tradition: "Baháʼí",
      description: "Commemorates Baháʼu'lláh's declaration as the Promised One.",
      date: {
        type: "fixed",
        value: "2024-04-21",
        timezone: "UTC"
      },
      scope: "public",
      regions: ["Worldwide"],
      aliases: ["Ridván"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: true,
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "ascension-bahaullah",
      name: "Ascension of Baháʼu'lláh",
      tradition: "Baháʼí",
      description: "Marks the passing of Baháʼu'lláh, founder of the Baháʼí Faith.",
      date: {
        type: "fixed",
        value: "2024-05-29",
        timezone: "UTC"
      },
      scope: "public",
      regions: ["Worldwide"],
      aliases: ["Ascension"],
      observance: {
        beginsAtSunset: true,
        workRestrictions: true,
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    }
  ];
  return holidays;
}

