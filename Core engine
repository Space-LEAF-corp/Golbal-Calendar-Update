


// @ts-ignore: Type-only import for Ajv
import type AjvType from "ajv";
// @ts-ignore: Type-only import for ValidateFunction
import type { ValidateFunction } from "ajv";
let addFormats: (ajv: AjvType) => void;




/**
 * @typedef {import('ajv').default} AjvType
 * @typedef {import('ajv').ValidateFunction} ValidateFunctionType
 */
let ajvInstance: AjvType | null = null;
let validateFn: ValidateFunction | null = null;

async function getAjv(): Promise<{ ajv: AjvType; validateFn: ValidateFunction }> {
  if (!ajvInstance) {
    let Ajv;
    let schema;
    try {
      // @ts-ignore: Ignore if 'ajv' types are missing
      Ajv = (await import("ajv")).default;
    } catch (e) {
      throw new Error("Module 'ajv' not found. Please install it with 'npm install ajv'.");
    }
    if (!addFormats) {
      try {
        // @ts-ignore: ajv-formats may not be installed, fallback is handled below
        addFormats = (await import("ajv-formats")).default;
      } catch (e) {
        // Fallback: define a no-op if ajv-formats is missing
        console.warn("Warning: Module 'ajv-formats' not found. Some format validations may not work. Install it with 'npm install ajv-formats'.");
        addFormats = () => {};
      }
    }
    try {
      // @ts-ignore: Ignore if TypeScript cannot find the module
      schema = (await import("../schema/holiday.schema.json", { assert: { type: "json" } })).default;
    } catch (e) {
      try {
        // @ts-ignore: Ignore missing type declarations for JSON
        schema = require("../schema/holiday.schema.json");
      } catch (e2) {
        try {
          // Fallback: try reading the file directly if both import and require fail
          const fs = require("fs");
          const path = require("path");
          const schemaPath = path.resolve(__dirname, "../schema/holiday.schema.json");
          schema = JSON.parse(fs.readFileSync(schemaPath, "utf-8"));
        } catch (e3) {
          // If all attempts fail, provide a clearer error message
          throw new Error("Schema file '../schema/holiday.schema.json' not found or cannot be loaded. Please ensure it exists and is accessible.");
        }
      }
    }
    ajvInstance = new Ajv({ allErrors: true, strict: false });
    addFormats(ajvInstance);
    validateFn = ajvInstance.compile(schema);
  }
  return { ajv: ajvInstance, validateFn: validateFn };
}

export async function validateHoliday(h: unknown): Promise<Holiday> {
  const { ajv, validateFn } = await getAjv();
  if (!validateFn(h)) {
    const msg = ajv.errorsText(validateFn.errors, { separator: "\n" });
    throw new Error(`Invalid holiday:\n${msg}`);
  }
  return h as Holiday;
}





export interface Alias extends String {}

export function normalize(h: Holiday): Holiday {
  const out: Holiday = { ...h };
  // Ensure lowercase id slugs and stable timestamps
  out.id = h.id.trim().toLowerCase().replace(/[^a-z0-9-]/g, "-");
  out.updatedAt = new Date().toISOString();

  // Default timezone
  if (!out.date.timezone) out.date.timezone = "UTC";

  // If range missing end, assume same-day
  if (out.date.type === "range" && !out.date.end && out.date.start) {
    out.date.end = out.date.start;
  }

  // Deduplicate aliases
  if (out.aliases) {
    out.aliases = Array.from(new Set(out.aliases.map((a: string) => a.trim()))).filter(Boolean) as string[];
  }
  return out;
}





export function mergeHolidays(sources: Holiday[][]): Holiday[] {
  const map = new Map<string, Holiday>();
  for (const src of sources) {
    for (const h of src) {
      const key = h.id;
      const existing = map.get(key);
      if (!existing) {
        map.set(key, h);
      } else {
        // Prefer newest updatedAt; merge arrays/fields
        const newer = (h.updatedAt ?? "") > (existing.updatedAt ?? "") ? h : existing;
        const merged: Holiday = {
          ...existing,
          ...h,
          aliases: Array.from(new Set([...(existing.aliases ?? []), ...(h.aliases ?? [])])),
          links: Array.from(new Set([...(existing.links ?? []), ...(h.links ?? [])]))
        };
        // Preserve the newer date block whole (date rules must be atomic)
        merged.date = newer.date;
        merged.updatedAt = newer.updatedAt;
        map.set(key, merged);
      }
    }
  }
  // Sort deterministic: tradition, name, then id
  return Array.from(map.values()).sort((a, b) =>
    (a.tradition.localeCompare(b.tradition) ||
     a.name.localeCompare(b.name) ||
     a.id.localeCompare(b.id))
  );
}




// Inline definition for Holiday interface (copied from likely structure)
export interface Holiday {
  id: string;
  name: string;
  tradition: string;
  description?: string;
  date: {
    type: "fixed" | "range";
    value?: string;
    start?: string;
    end?: string;
    timezone?: string;
  };
  scope: string;
  regions?: string[];
  aliases?: string[];
  observance?: {
    beginsAtSunset?: boolean;
    workRestrictions?: string | boolean;
    fasting?: boolean;
  };
  year?: number;
  updatedAt?: string;
  links?: string[];
}
import { writeFileSync } from "fs";

export function exportJSON(holidays: Holiday[], path: string = "data/holidays.json"): void {
  writeFileSync(path, JSON.stringify(holidays, null, 2), "utf-8");
}

export function exportCSV(holidays: Holiday[], path: string = "data/holidays.csv"): void {
  const headers = ["id","name","tradition","type","value","start","end","timezone","scope","regions","beginsAtSunset","workRestrictions","fasting","year","updatedAt"];
  const rows = holidays.map(h => [
    h.id, h.name, h.tradition,
    h.date.type, h.date.value ?? "", h.date.start ?? "", h.date.end ?? "", h.date.timezone ?? "",
    h.scope, (h.regions ?? []).join(";"),
    h.observance?.beginsAtSunset ?? false,
    h.observance?.workRestrictions ?? "",
    h.observance?.fasting ?? false,
    h.year ?? "",
    h.updatedAt ?? ""
  ]);
  const csv = [headers.join(","), ...rows.map(r => r.map(v => String(v).replace(/"/g, '""')).map(v => `"${v}"`).join(","))].join("\n");
  writeFileSync(path, csv, "utf-8");
}

export function exportICS(holidays: Holiday[], path: string = "data/holidays.ics"): void {
  const lines = ["BEGIN:VCALENDAR","VERSION:2.0","PRODID:-//GlobalHolidayCalendar//EN"];
  for (const h of holidays) {
    const dtStart = (h.date.type === "fixed" ? h.date.value : h.date.start) ?? "";
    const dtEnd = (h.date.type === "range" ? h.date.end : dtStart) ?? dtStart;
    if (!dtStart) continue;
    const start = dtStart.replace(/-/g, "") + "T000000Z";
    const end = dtEnd.replace(/-/g, "") + "T235959Z";
    lines.push(
      "BEGIN:VEVENT",
      `UID:${h.id}@globalholiday.calendar`,
      `DTSTAMP:${(h.updatedAt ?? new Date().toISOString()).replace(/[-:]/g, "").split(".")[0]}Z`,
      `DTSTART:${start}`,
      `DTEND:${end}`,
      `SUMMARY:${escapeICS(h.name)} (${h.tradition})`,
      `DESCRIPTION:${escapeICS(h.description ?? "")}`,
      "END:VEVENT"
    );
  }
  lines.push("END:VCALENDAR");
  require("fs").writeFileSync(path, lines.join("\r\n"), "utf-8");

  function escapeICS(s: string): string {
    return s.replace(/\\/g, "\\\\").replace(/;/g, "\\;").replace(/,/g, "\\,").replace(/\n/g, "\\n");
  }
}





// import { validateHoliday } from "./core/validate";
import process from "process";
// import { normalize } from "./core/normalize";
// import { mergeHolidays } from "./merge";
// exportJSON, exportCSV, exportICS are defined locally below
import { createRequire } from "module";
const require = createRequire(import.meta.url);
interface Adapter {
  run: () => Promise<Holiday[]>;
}
let adapters: Adapter[] = [];
try {
  adapters = require("./adapters/user-contrib").adapters;
} catch (e) {
  // If the module doesn't exist, use an empty array
  adapters = [];
}
// import { staticJewish } from "./adapters/static-jewish";
// import { staticIslamic } from "./adapters/static-islamic";
// import { staticChristian } from "./adapters/static-christian";
// import { staticBahai } from "./adapters/static-bahai";
// import { staticHindu } from "./adapters/static-hindu";
// import { staticBuddhist } from "./adapters/static-buddhist";

async function build(): Promise<void> {
  const allSources: Holiday[][] = [];
  // Run adapters concurrently

  const results: Holiday[][] = await Promise.all([
    staticJewish(),
    // Stub for staticIslamic to fix reference error
    (async function staticIslamic(): Promise<Holiday[]> {
      // TODO: Implement actual Islamic holidays
      return [];
    })(),
    // staticChristian(),
    staticBahai(),
    staticHindu(),
    // staticBuddhist(),
    ...adapters.map((a: Adapter) => a.run())
  ]);


  for (const res of results) {
    const cleaned: Promise<Holiday>[] = res.map((h: unknown) => validateHoliday(h).then(normalize));
    allSources.push(await Promise.all(cleaned));
  }

  const merged = mergeHolidays(allSources);
  exportJSON(merged);
  exportCSV(merged);
  exportICS(merged);
  console.log(`Built ${merged.length} holidays -> data/holidays.*`);
}

build().catch(err => {
  console.error(err);
  process.exit(1);
});



async function staticHindu(): Promise<Holiday[]> {
  // Example static Hindu holidays (fixed dates for demonstration)
  const holidays: Holiday[] = [
    {
      id: "diwali",
      name: "Diwali",
      tradition: "Hindu",
      description: "Festival of Lights, one of the most important Hindu festivals.",
      date: {
        type: "fixed",
        value: "2024-11-01",
        timezone: "Asia/Kolkata"
      },
      scope: "public",
      regions: ["IN", "NP", "MU", "FJ", "MY", "SG", "TT"],
      aliases: ["Deepavali"],
      observance: {
        beginsAtSunset: true,
        workRestrictions: "Major festival, often a public holiday.",
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "holi",
      name: "Holi",
      tradition: "Hindu",
      description: "Festival of Colors, celebrating the arrival of spring.",
      date: {
        type: "fixed",
        value: "2024-03-25",
        timezone: "Asia/Kolkata"
      },
      scope: "public",
      regions: ["IN", "NP", "BD", "PK"],
      aliases: ["Festival of Colors"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: "Public holiday in many regions.",
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "maha-shivaratri",
      name: "Maha Shivaratri",
      tradition: "Hindu",
      description: "Great Night of Shiva, a major festival dedicated to Lord Shiva.",
      date: {
        type: "fixed",
        value: "2024-03-08",
        timezone: "Asia/Kolkata"
      },
      scope: "public",
      regions: ["IN", "NP"],
      aliases: ["Shivaratri"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: "Observed with fasting and night-long vigil.",
        fasting: true
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    }
  ];
  return holidays;
}

async function staticBahai(): Promise<Holiday[]> {
  // Example static Baháʼí holidays (fixed dates for demonstration)
  const holidays: Holiday[] = [
    {
      id: "naw-ruz",
      name: "Naw-Rúz",
      tradition: "Baháʼí",
      description: "Baháʼí New Year, coincides with the vernal equinox.",
      date: {
        type: "fixed",
        value: "2024-03-20",
        timezone: "UTC"
      },
      scope: "public",
      regions: ["IR", "AZ", "UZ", "TM", "KG", "KZ", "AF", "PK", "IN", "BD", "Worldwide"],
      aliases: ["Nowruz", "Baháʼí New Year"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: true,
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "ridvan-1",
      name: "First Day of Ridván",
      tradition: "Baháʼí",
      description: "Commemorates Baháʼu'lláh's declaration as the Promised One.",
      date: {
        type: "fixed",
        value: "2024-04-21",
        timezone: "UTC"
      },
      scope: "public",
      regions: ["Worldwide"],
      aliases: ["Ridván"],
      observance: {
        beginsAtSunset: false,
        workRestrictions: true,
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "ascension-bahaullah",
      name: "Ascension of Baháʼu'lláh",
      tradition: "Baháʼí",
      description: "Marks the passing of Baháʼu'lláh, founder of the Baháʼí Faith.",
      date: {
        type: "fixed",
        value: "2024-05-29",
        timezone: "UTC"
      },
      scope: "public",
      regions: ["Worldwide"],
      aliases: ["Ascension"],
      observance: {
        beginsAtSunset: true,
        workRestrictions: true,
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    }
  ];
  return holidays;
}

async function staticJewish(): Promise<Holiday[]> {
  // Example static Jewish holidays (fixed dates for demonstration)
  const holidays: Holiday[] = [
    {
      id: "rosh-hashanah",
      name: "Rosh Hashanah",
      tradition: "Jewish",
      description: "Jewish New Year, beginning the High Holy Days.",
      date: {
        type: "fixed",
        value: "2024-10-03",
        timezone: "Asia/Jerusalem"
      },
      scope: "public",
      regions: ["IL", "US", "CA", "Worldwide"],
      aliases: ["Jewish New Year"],
      observance: {
        beginsAtSunset: true,
        workRestrictions: "Work is prohibited.",
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "yom-kippur",
      name: "Yom Kippur",
      tradition: "Jewish",
      description: "Day of Atonement, the holiest day in Judaism.",
      date: {
        type: "fixed",
        value: "2024-10-12",
        timezone: "Asia/Jerusalem"
      },
      scope: "public",
      regions: ["IL", "US", "CA", "Worldwide"],
      aliases: ["Day of Atonement"],
      observance: {
        beginsAtSunset: true,
        workRestrictions: "Work is prohibited. 25-hour fast.",
        fasting: true
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    },
    {
      id: "passover-1",
      name: "Passover (First Day)",
      tradition: "Jewish",
      description: "Commemorates the Exodus from Egypt.",
      date: {
        type: "fixed",
        value: "2024-04-23",
        timezone: "Asia/Jerusalem"
      },
      scope: "public",
      regions: ["IL", "US", "CA", "Worldwide"],
      aliases: ["Pesach"],
      observance: {
        beginsAtSunset: true,
        workRestrictions: "Work is prohibited on first and last days.",
        fasting: false
      },
      year: 2024,
      updatedAt: new Date().toISOString()
    }
  ];
  return holidays;
}

